\documentclass{article}
\usepackage{polski}
\usepackage{blindtext}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{graphicx} 
\usepackage{amssymb}
\usepackage[a4paper, left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm, headsep=1.2cm]{geometry}

\usepackage{titling}
\newcommand{\subtitle}[1]{%
  \posttitle{%
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.5em}%
}


\begin{document}
\title{\textsc{Sprawozdanie - laboratorium 4}}
\subtitle{\textbf{Wyznaczanie wartości i wektorów własnych macierzy symetrycznej}}
\author{Zuzanna Grzesik}
\date{25 marca 2020}

\maketitle	

\section{Wstęp teoretyczny}	

\subsection{Wartości własne oraz wektory własne macierzy}
Niech A będzie kwadratową macierzą $n \times n$. Wówczas $A$ wyznacza przekszłałcenie liniowe przestrzeni $\mathbb{R}_n$ w siebie. \par Niech $v \in \mathbb{R}_n$ będzie pewnym niezerowym wektorem oraz niech $L = \{t \cdot v : t \in \mathbb{R}\}$ będzie prostą wyznaczoną przez ten wektor.
Jeżeli przekształcenie $A$ przekształca prostą $L$ w siebie, to mówimy, że $v$ jest wektorem własnym przekształcenia $A$. Oznacza to, że
\begin{equation} A \cdot v= \lambda \cdot v \end{equation}
dla pewnej liczby rzeczywistej $\lambda$, zwanej wartością własną związaną z wektorem własnym $v$. \cite{1}
Dzięki własnościom i wektorom własnym możemy np. dokonać diagonalizacji, która z kolei może być przydatna do rozwiązywania układów równań różniczkowych.

\subsection{Transformacja Householdera}
Transformacja Householdera (zwana też Redukcją Householdera) to metoda pozwalająca na zredukowanie symetrycznej macierzy \textbf{A} do tridiagonalnej formy w $n-2$ ortogonalnych przekształceniach. Podstawowym elementem, na którym wykonywane są operacje w tej metodzie jest macierz \textbf{P} postaci:
\begin{equation}
\textbf{P} = 1 - 2w \cdot w^{T}
\end{equation}
gdzie $w$ jest rzeczywistym wektorem spełniającym warunek $|w|^2 = 1$. Macierz \textbf{P} jest ortogonalną ponieważ $\textbf{P}^2 = 1$.
\textbf{P} zostanie nadpisana jako:
\begin{equation}
\textbf{P} = 1 - \frac{u \cdot u^T}{H},
\end{equation}
gdzie $H \equiv \frac{1}{2} |u|^2 $, a $u$ może być dowolnym wektorem. Niech $x$ będzie wektorem powstałym z pierwszej kolumny \textbf{A}. Wybieramy $u$ postaci:
\begin{equation}
\textbf{u} = \textbf {x} \mp | \textbf{x} | \textbf{e}_1 ,
\end{equation}
gdzie $\textbf{e}_1$ jest wektorem jednostkowym $[1, 0 , . . .  ,0]^T$.  Następnie:
\begin{equation}
\begin{array}{c}
\textbf{P} \cdot \textbf{x} = \textbf{x} - \frac{\textbf{u}}{H} \cdot (\textbf{x} \mp |\textbf{x}|\textbf{e}_1)^T \cdot \textbf{x} \\
= \textbf{x} - \frac{2\textbf{u} \cdot (| \textbf{x}|^2 \mp | \textbf{x}| x_1)}{2| \textbf{x}|^2 \mp 2| \textbf{x}| x_1} \\
= \textbf{x} - \textbf{u} \\
= \pm |\textbf{x}| \textbf{e}_1
\end{array}
\end{equation}
Powyższe działanie pokazuje, że macierz \textbf{P} zeruje wszystkie elementy wektora \textbf{x} z wyjątkiem pierwszego. By dokonać redukcji macierzy \textbf{A} do postaci trójdiagonalej, wybieramy wektor \textbf{x} dla pierwszej macierzy Householdera, tak by był $n - 1$ dolnymi elementami pierwszej kolumny. Wtedy $n - 2$ dolnych elementów zostanie wyzerowanych.
\begin{equation}
	\begin{array}{c}
	\textbf{P}_1 \cdot \textbf{A} = 
	\begin{bmatrix}
	\begin{array}{c|c}
		1 &  0  0  \cdots 0 \\
		\hline \\
		0 \\
		0 \\
		\vdots &              (n-1)\textbf{P}_1\\
		0
	\end{array}	
	\end{bmatrix}
	\cdot
	\begin{bmatrix}
	\begin{array}{c|c}
		a_{11} &  a_{12}  a_{13}  \cdots a_{1n} \\
		\hline 
		a_{21} \\
		a_{31} \\
		\vdots &              nieistotne\\
		a{n1}
	\end{array}	
	\end{bmatrix} \\
	= 
	\begin{bmatrix}
	\begin{array}{c|c}
		a_{11} &  a_{12}  a_{13}  \cdots a_{1n} \\
		\hline 
		k \\
		0 \\
		\vdots &              nieistotne\\
		0
	\end{array}	
	\end{bmatrix}
	\end{array}
\end{equation}
gdzie $k$:
\begin{equation}
k = \textbf{P}' _1 
	\begin{pmatrix}
	a_{21} \\
	\vdots \\
	a_{n1}
	\end{pmatrix}
	= \pm |
	\begin{pmatrix}
	a_{21} \\
	\vdots \\
	a_{n1}
	\end{pmatrix}
	|
\end{equation}
Operację tą wykonuje się dla wszystkich wektorów by finalnie otrzymać pełną ortogonalną transformację postaci:
\begin{equation}
\textbf{T} = \textbf{P}^{-1} \cdot \textbf{A} \cdot \textbf{P} = 
	\begin{bmatrix}
	a_{11} & | & k & 0 & \cdots & 0 \\
	- & | & - & - & - & - \\
	k & | \\
	0 & | \\
	\vdots & | & & nieistotne &   \\
	0 & |\\
	\end{bmatrix}	
\end{equation}
Jak widać, macierz \textbf{T} jest macierzą trójdiagonalną. Posiada ona pojedyncze wartości i wektory własne, a ze względu na jej postać można je obliczyć wykonując stosunkowo mało operacji. 

\subsection{Rozkład QR metodą Householdera \cite{2} }
Rozkład $QR$ to rozkłąd macierzy do postaci iloczynu dwóch macierzy \textbf{Q} i \textbf{R}, gdzie \textbf{Q} jest macierzą ortogonalną (czyli $\textbf{Q}^T\textbf{Q} = \textbf{I}$), a \textbf{R} jest macierzą trójkątną górną. Rozkład ten mozna wykonać korzystając z metody Householdera.
Definiujemy macierz Householdera postaci: 
\begin{equation}
\textbf{H} = \textbf{I} - \frac{1}{\tau} \textbf{uu}^H, \textbf{u} = \textbf{z} - \alpha \| \textbf{z} \| _2 \textbf{e}_1
\end{equation}
gdzie: $\alpha = \pm 1 = -sign(z_1)$, $\textbf{z} = [z_1, z_2, ..., z_n]^T$,  $e_1 = [1, 0, ... , 0]^T$, $\tau = \|z\|_2(\|z\|_2 - \alpha)$. Macierz ta ma własność:
\begin{equation}
\textbf{Hz} = \alpha \|z\|_2 [1, 0, ... , 0]^T .
\end{equation}
Określamy ciąg macierzy $\textbf{P}^{(1)}, \textbf{P}^{(2)}, \textbf{P}^{(3)}, ..., \textbf{P}^{(n-1)}$ prz pomocy których definiujemy macierz R - górną trójkątną. 
\begin{equation}
\textbf{P}^{(n-1)} \textbf{P}^{(n-2)} \cdots \textbf{P}^{(1)} \textbf{A} = \textbf{R}.
\end{equation}
Zakładamy, że $\textbf{P}^{(1)} = \textbf{P}^{(H)}$, gdzie macierz $\textbf{H}^{(1)}$ jest macierzą Householdera, która sprowadza pierwszą kolumnę macierzy \textbf{A} do postaci:
\begin{equation}
\alpha^{(1)} \| a^{(1)} \| _2 [1, 0, ... , 0]^T _{1 \times n}.
\end{equation}
Kolejna macierz przekształceń $\textbf{P}^{(2)}$ będzie postaci:
\begin{equation}
\textbf{P}^{(2)} = 
\begin{bmatrix}
	1 & \vdots & 0 \\
	\cdots & \cdots & \cdots \\
	0 & \vdots & \textbf{H}^{(2)}
\end{bmatrix}.
\end{equation}
Podobnie jak poprzednio macierz \textbf{H$^{(2)}$}sprowadza pierwszą kolumnę macierzy o wymiarze $(n-1) \times (n-1)$ utworzonej z wierszy i kolumn o numerach $2,3,4,...,n$ macierzy 
$\textbf{P}^{(1)}\textbf{A}(a^{(2)}_1)$ do postaci:
\begin{equation}
\alpha_2\| a^{(2)}_1 \| _2 [1, 0, ... , 0]^T _{1 \times (n-1)}.
\end{equation}
W ten sposób postępujemy z kolejnymi macierzami z ciągu macierzy \textbf{P}. Ostatnia macierz $\textbf{P}^{(n-1)}$ ma postać:
\begin{equation}
\textbf{P}^{(n-1)} = 
\begin{bmatrix}
	1 &   &  &  \\
	 & 1 & & \\
	  &  & 1 & \\
	   & & & \textbf{H}^{(n-1)}
\end{bmatrix}.
\end{equation}
gdzie macierz $\textbf{H}^{(n-1)}$ ma wymiar $2 \times 2$. Gdy wyznaczymy wszystkie macierze \textbf{P}, rozkład $\textbf{A = QR}$ wyznaczamy według wzorów:
\begin{equation}
\textbf{Q} = \displaystyle\prod_{i=1}^{n-1} \textbf{P}^{(i)}, \textbf{R} = \textbf{Q}^T \textbf{A}.
\end{equation}.
Korzystając z rozkładu $QR$ macierzy \textbf{A} możemy wyznaczyć jej wartości i wektory własne. W metodzie $QR$ dokonujemy przekształceń, które można uogólnić do postaci:
\begin{equation}
\textbf{A}_{k+1} = \textbf{Q}^{-1}_{k} \textbf{Q}^{-1}_{k-1} \cdots \textbf{Q}^{-1}_{1} \textbf{A} \textbf{Q}_{1} \textbf{Q}_{2} \cdots \textbf{Q}_{k}
\end{equation}
Dla $\textbf{P} = \textbf{P}_k = \textbf{Q}_{1} \textbf{Q}_{2} \cdots \textbf{Q}_{k}$ mamy $\textbf{P}^{-1} = \textbf{P}^{-1}_k = \textbf{Q}^{-1}_{k}$ \textbf{Q}^{-1}_{k-1} \cdots \textbf{Q}^{-1}_{1}$. Wówczas prawdziwe jest równanie:
\begin{equation}
\textbf{P}^{-1} \textbf{A} \textbf{P} = \textbf{A}_{k+1} = \textbf{H}
\end{equation}
gdzie macierz $\testbf{A}_{k+1}$ jest macierzą trójkątną górną z wartościami własnymi na swojej diagonali. Wektor własny $\textbf{x}^{(i)}$ tej macierzy przynależy do odpowiedniej wartości własnej $\lambda _i = h_{ii}$ (gdzie $h_{ii}$ to \nolinebreak element o \nolinebreak indeksie $i$ na diagonali macierzy $\textbf{A}_{k+1}$ czyli również macierzy \textbf{H}). Wektory własne wyznacza się według wzorów:
\begin{equation}
\begin{array}{l}
x^{(i)}_j = 0, j = n, n-1, \cdots, i+1 \\
x^{(i)}_i = 1 \\
x^{(i)}_j = - \frac{ \sum_{k=j+1}^{i} h_{jk}x^{(i)}_k}{h_{jj} - h{ii}}, j = i-1, i-2, \cdots, 1.
\end{array}
\end{equation}
Gdy mamy wyznanczone wektory własne macierzy \textbf{H} możemy obliczyć wektory własne macierzy pierwotnej \textbf{A}, przekształcając odpowiednio wzory:
\begin{equation}
\begin{array}{c}
\textbf{P}^{-1}\textbf{AP} = \textbf{H} \\
\textbf{Hx} = \lambda \textbf{x} \\
\textbf{P}^{-1}\textbf{APx} = \textbf{Hx} = \lambda \textbf{x}  \\
\textbf{A}(\textbf{Px}) = \lambda\textbf{Px} \\
\texbf{y} = \textbf{Px} \\
\textbf{Ay} = \lambda \textbf{y}
\end{array}.
\end{equation}
Algorytm ten można zmodyfikować do postaci $QL$, gdzie \textbf{L} to macierz trójkątna dolna. 

\section{Zadanie do wykonania}
\subsection{Opis problemu}
Głównym zadaniem podczas laboratoriów było znalezienie wektorów i wartości własnych macierzy $\textbf{A}$ o \nolinebreak wymiarze $n = 5$. Elementy macierzy zostały zdefiniowane w następujący sposób:
\begin{equation}
A_{ij} = \sqrt{i+j},
\end{equation}
gdzie; $i,j = 1,2,3,4,5$. W trakcie wykonywania zadania należało skorzystać z funkcji \texttt{tred2} oraz \texttt{tqli} z \nolinebreak bibliotek Numerical Recipes i można było wykonać je na dwa sposoby. W obu z nich należało rozpocząć od skorzystania z procedury \texttt{tred2} i dokonać redukcji macierzy $\textbf{A}$ do postaci trójdiagonalnej. W efekcie macierz A została nadpisana macierzą przekształcenia \textbf{P}, a także zwrócone zostały wektory $d$ i $e$, w \nolinebreak których zapisano odpowiednio składowe diagonali i poddiagonali macierzy trójdiagonalnej $\textbf{T}$ postaci:
\begin{equation}
	\textbf{T} = 
	\begin{pmatrix}
	d[1] & e[2] & 0 & 0 & 0 \\
	e[2] & d[2] & e[3] & 0 & 0 \\
	0 & e[3] & d[3] & e[4] & 0 \\
	0 & 0 & e[4] & d[4] & e[5] \\
	0 & 0 & 0 & e[5] & d[5]
	\end{pmatrix}
\end{equation}
Macierz $\textbf{A}$ została więc przekształcona do postaci:
\begin{equation}
\textbf{T} = \textbf{P}^{-1} \textbf{A P}.
\end{equation}
Następnie korzystając z procedury \texttt{tqli} możemy znaleźć wektory własne macierzy $\textbf{T}$, które po odpowiednich przekształceniach (opisanych w równaniu (20)) dadzą nam wektory własne macierzy $\textbf{A}$ lub od razu wywołać w odpowiedni sposób funkcje by od razu otrzymać wektory własne $\textbf{A}$.  Funkcja \texttt{tqli} przyjmuje parametry: \texttt{float d[]} - wektor elementów diagonalnych macierzy $\textbf{T}$, który jest po wywołaniu funkcji nadpisywany jest wartościami własnymi, \texttt{float e[]} - wektor elementów pozadiagonalnych macierzy $\textbf{T}$, \texttt{int n} - rozmiar macierzy,  \texttt{float **Y} - macierz jednostkowa rozmiaru $n \times n$, która nadpisywana wektorami własnymi macierzy \textbf{T} (ułożonych kolumnami). Jednakże, gdy wywołamy funkcje z ostatnim parametrem jako macierzą przekształceń $\textbf{P}$ (uzyskaną przez wcześniejsze wywołanie funkcji \texttt{tred2}), otrzymamy od razu wektory własne macierzy $\textbf{A}$, które w tym przypadku również nadpiszą macierz - ostatni parametr funkcji. Dzięki temu otrzymujemy od razu szukane przez nas wartości i nie musimy wykonywać dodatkowych przekształceń. 
\par Ostatnią częścią zadania było sprawdzić czy obliczone wartości własne macierzy $\textbf{A}$ rzeczywiście nimi są obliczając wartości $\beta_k$, według wzoru:
\begin{equation}
\beta_k = \frac{(x_k, Ax_k)}{(x_k, x_k)},
\end{equation}
gdzie: $(x_k, Ax_k)$ to iloczyn skalarny macierzowy $\textbf{A}$, a $(x_k, x_k)$ jest iloczyn skalarnym tych dwóch wektorów. Dla ułatwienia obliczeń dokonałam odpowiednich przekształceń na macierzach. Utworzyłam macierz $\textbf{Z} = \nolinebreak \textbf{AX}$ (\textbf{X} to macierz z wyjściowa przy wywołaniu funkcji \texttt{tqli}). Następnie liczniki kolejnych wartości $\beta$ obliczałam jako iloczyn skalarny $k$ - tej kolumny macierzy \textbf{X} oraz $k$-tej kolumny macierzy \textbf{Z}, a \nolinebreak mianowniki jako iloczyn skalarny $k$ - tej kolumny macierzy \textbf{X} z nią samą.
\par Do wykonywanego zadania stworzyłam dodatkowo funkcje pomocnicze: obliczającą mnożenie dwóch macierzy, obliczającą iloczyn skalarny oraz wykonującą transpozycje macierzy (przydatna do obliczeń z \nolinebreak wektorami, które były zapisane jako kolumny w macierzy).
\subsection{Wyniki}
Macierz \textbf{P} przekształcenia Householdera jest postaci:
\begin{equation}
	\textbf{P} = 
	\begin{pmatrix}
	 0.127995 & 0.473318 & 0.748056 & -0.447214 & 0 \\
	-0.559029 & -0.639797 & 0.21169 & -0.483046 & 0 \\
	0.75337 & -0.341655 & -0.221449 & -0.516398 & 0 \\
	-0.321774 & 0.499901 & -0.588694 & -0.547723 & 0 \\
	0 & 0 & 0 & 0 & 1	
	\end{pmatrix}.
\end{equation}
Wektory własne macierzy \textbf{A}:
\begin{equation}
x_1 = 
\begin{pmatrix}
	-0.0346135 \\ 0.263629 \\ -0.656232 \\ 0.664969 \\ -0.23765 
\end{pmatrix}
x_2 = 
\begin{pmatrix}
	-0.186354 \\ 0.645677 \\ -0.376067 \\ -0.49145 \\ 0.406723 
\end{pmatrix}
x_3 = 
\begin{pmatrix}
	-0.526489 \\ 0.492809 \\  0.477178 \\ 0.0704053 \\ -0.497285 
\end{pmatrix}
x_4 = 
\begin{pmatrix}
	0.744285 \\ 0.322509 \\ -0.00630783 \\ -0.279018  \\ -0.513943  
\end{pmatrix}
x_5 = 
\begin{pmatrix}
	0.364587 \\ 0.408323 \\ 0.447431 \\ 0.483203 \\ 0.5164 
\end{pmatrix}
\end{equation}
Obliczone wartości własne macierzy \textbf{A} oraz wartości $\beta_k$
\begin{equation}
\begin{array}{|c|r|r|}
k & \lambda_k & \beta_k \\
\hline
1 & -2.4575e-07 & -4.74193e-07 \\
2 & -7.34517e-05 & -7.36331e-05 \\
3 & -0.00511678 & -0.00511692  \\
4 & -0.381893 & -0.381893\\
5 & 12.2415 & 12.2415
\end{array}
\end{equation}
Jak widać w powyższej tabeli, pomiędzy wynikami pojawiają się rozbieżności gdy popatrzymy na wartości na 5-7 miejscu po przecinku. 

\section{Wnioski}
Dzięki funkcjom \texttt{tred2} i \texttt{tqli} możemy w szybki sposób znaleźć wartości i wektory własne macierzy. Dodatkową zaletą jest to, że funkcje te zostały zaprojektowane, by ze sobą współdziałać, dzięki czemu otrzymujemy szukane przez nas wartości, bez konieczności wykonywania dodatkowych przekształceń. Warto zauważyć, że funkcja \texttt{tqli} nie operuje na całej macierzy trójdiagonalnej, a jedynie na wektorach z zapisanymi elementami diagonali i poddiagonali, dzięki czemu oszczędzana jest pamięć i złożoność obliczeniowa algorytmu ''maleje" z $O(n^3)$ do $O(n)$. Jednakże, metoda może być niedokładna dla bardzo małych wartości (5-7 miejsc po przecinku), o czym świadczą rozbieżności w wynikach obliczeń wartości własnych. Niedokładności wynikają z zastosowanych przez twórców funkcji przybliżeń. 

\begin{thebibliography}{9}

\bibitem{1}
  Szymon Toruńczyk, \emph{Wartości własne oraz wektory własne macierzy} 
  \texttt{https://www.mimuw.edu.pl/~szymtor/wartwl.pdf}

\bibitem{2}
  Tomasz Chwiej, \emph{Wyznaczanie wartości i wektorów własnych macierzy} 
  \texttt{http://galaxy.agh.edu.pl/~chwiej/mn/diagonalizacja\_2018.pdf}

\end{thebibliography}


\end{document}
